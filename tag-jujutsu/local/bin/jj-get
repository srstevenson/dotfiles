#!/usr/bin/env -S uv run --script
#
# /// script
# requires-python = ">=3.14"
# dependencies = []
# ///

"""Clone Git repositories with Jujutsu into ~/dev."""

import argparse
import subprocess
from dataclasses import dataclass
from pathlib import Path
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable


@dataclass(kw_only=True)
class Args(argparse.Namespace):
    """Command-line arguments."""

    url: str = ""


def expand_url(url: str) -> str:
    """Expand a shorthand URL to a full clone URL.

    We check if the provided URL starts with `https://` or `git@`, which
    indicate a full remote URL. Otherwise, expand GitHub `project` and
    `owner/project` shorthands, and URLs missing schemes, to full clone URLs.

    Args:
        url: The input remote URL or GitHub shorthand.

    Returns:
        The expanded remote URL.

    """
    if url.startswith(("https://", "git@")):
        return url

    if "/" not in url:
        return f"git@github.com:srstevenson/{url}.git"

    head, tail = url.split("/", maxsplit=1)

    if "." in head:
        # Assume `head` is a hostname if it contains `.`.
        return f"https://{head}/{tail}"

    if head == "srstevenson":
        return f"git@github.com:srstevenson/{tail}.git"

    return f"https://github.com/{url}.git"


def parse_args() -> Args:
    """Parse command-line arguments.

    Returns:
        Parsed arguments with the expanded remote URL.

    """
    parser = argparse.ArgumentParser(
        description="Clone Git repositories with Jujutsu into ~/dev"
    )
    parser.add_argument(
        "url",
        type=expand_url,
        help="remote URL or GitHub shorthand (`project` or `user/project`)",
    )
    return parser.parse_args(namespace=Args())


def matches_hosts(url: str, hosts: Iterable[str]) -> bool:
    """Check if a remote URL matches any of the specified Git hosts.

    We check for both HTTPS and SSH clone URLs for each of the provided hosts.

    Args:
        url: The remote URL to check.
        hosts: A collection of host names.

    Returns:
        True if URL is a HTTPS or SSH URL for any provided host.

    """
    return any(url.startswith((f"https://{host}/", f"git@{host}:")) for host in hosts)


def unpack_host_and_path(url: str) -> tuple[str, str]:
    """Extract host and repository path from a Git remote URL.

    The Git remote URL can be either in SSH or HTTPS format. For SSH URLs
    (containing `@`), we split the URL appropriately to extract the host and
    repository path. For HTTPS URLs, the `https://` prefix is removed and the
    remainder is split on `/`. The repository path is normalised by removing any
    leading `~` character (for SourceHut URLs) and the trailing `.git` suffix.

    Args:
        url: The full remote URL.

    Returns:
        Tuple of host and repository path.

    """
    if "@" in url:
        host, repo = url.split("@", maxsplit=1)[1].split(":", maxsplit=1)
    else:
        host, repo = url.removeprefix("https://").split("/", maxsplit=1)

    return host, repo.lstrip("~").removesuffix(".git")


def main() -> None:
    """Command-line entry point."""
    args = parse_args()

    host, path = unpack_host_and_path(args.url)
    url = args.url

    if path.startswith("srstevenson/"):
        if host in ["codeberg.org", "github.com", "gitlab.com"]:
            url = f"git@{host}:{path}.git"
        elif host == "git.sr.ht":
            url = f"git@{host}:~{path}"
    elif matches_hosts(args.url, ["codeberg.org", "github.com", "gitlab.com"]):
        if not args.url.startswith("git@"):
            url = f"https://{host}/{path}.git"
    elif matches_hosts(args.url, ["git.sr.ht"]) and not args.url.startswith("git@"):
        url = f"https://{host}/~{path}"

    subprocess.run(  # noqa: S603
        ["jj", "git", "clone", url, Path.home().joinpath("dev", host, path)],  # noqa: S607
        check=False,
    )


if __name__ == "__main__":
    main()
